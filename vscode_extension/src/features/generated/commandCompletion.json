{
    "END_USE_CODE": {
        "description": "end of USE_CODE_IF",
        "signature": "END_USE_CODE",
        "snippet_string": "END_USE_CODE"
    },
    "NO_SYS_SCRIPT_GROUP_START": {
        "description": "condition; if defined with SET_CONDITION(), the system script which handles all group start options will be bypassed",
        "signature": "NO_SYS_SCRIPT_GROUP_START",
        "snippet_string": "NO_SYS_SCRIPT_GROUP_START"
    },
    "NO_SYS_SCRIPT_PEDAL": {
        "description": "condition; if defined with SET_CONDITION(), the system script which sustains notes when CC# 64 is received will be bypassed",
        "signature": "NO_SYS_SCRIPT_PEDAL",
        "snippet_string": "NO_SYS_SCRIPT_PEDAL"
    },
    "NO_SYS_SCRIPT_RLS_TRIG": {
        "description": "condition; if defined with SET_CONDITION(), the system script which triggers samples upon the release of a key is bypassed",
        "signature": "NO_SYS_SCRIPT_RLS_TRIG",
        "snippet_string": "NO_SYS_SCRIPT_RLS_TRIG"
    },
    "RESET_CONDITION": {
        "description": "delete a definition",
        "signature": "RESET_CONDITION(condition-symbol)",
        "snippet_string": "RESET_CONDITION( ${1:condition-symbol} )"
    },
    "SET_CONDITION": {
        "description": "define a symbol to be used as a condition",
        "signature": "SET_CONDITION(condition-symbol)",
        "snippet_string": "SET_CONDITION( ${1:condition-symbol} )"
    },
    "USE_CODE_IF": {
        "description": "interpret code when <condition> is defined",
        "signature": "USE_CODE_IF(condition-symbol)",
        "snippet_string": "USE_CODE_IF( ${1:condition-symbol} )"
    },
    "USE_CODE_IF_NOT": {
        "description": "interpret code when <condition> is not defined",
        "signature": "USE_CODE_IF_NOT(condition-symbol)",
        "snippet_string": "USE_CODE_IF_NOT( ${1:condition-symbol} )"
    },
    "_delay_event_for_loading_slots": {
        "description": "Undocumented",
        "signature": "_delay_event_for_loading_slots(arg1)",
        "snippet_string": "_delay_event_for_loading_slots( ${1:arg1} )"
    },
    "_get_engine_par": {
        "description": "returns the value of a specific engine parameter",
        "signature": "_get_engine_par(parameter,group,slot,generic)",
        "snippet_string": "_get_engine_par( ${1:parameter}, ${2:group}, ${3:slot}, ${4:generic} )"
    },
    "_get_engine_par_disp": {
        "description": "returns the displayed string of a specific engine parameter",
        "signature": "_get_engine_par_disp(parameter,group,slot,generic)",
        "snippet_string": "_get_engine_par_disp( ${1:parameter}, ${2:group}, ${3:slot}, ${4:generic} )"
    },
    "_get_folder": {
        "description": "returns the path specified with the built-in path variable",
        "signature": "_get_folder(path-variable)",
        "snippet_string": "_get_folder( ${1:path-variable} )"
    },
    "_load_ir_sample": {
        "description": "loads an impulse response sample into KONTAKT's convolution effect",
        "signature": "_load_ir_sample(file-path,slot,generic)",
        "snippet_string": "_load_ir_sample( ${1:file-path}, ${2:slot}, ${3:generic} )"
    },
    "_num_slices": {
        "description": "Undocumented",
        "signature": "_num_slices(arg1)",
        "snippet_string": "_num_slices( ${1:arg1} )"
    },
    "_pgs_create_key": {
        "description": "It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script.",
        "signature": "_pgs_create_key(key-id,size)",
        "snippet_string": "_pgs_create_key( ${1:key-id}, ${2:size} )"
    },
    "_pgs_get_key_val": {
        "description": "It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script.",
        "signature": "_pgs_get_key_val(key-id,index)",
        "snippet_string": "_pgs_get_key_val( ${1:key-id}, ${2:index} )"
    },
    "_pgs_key_exists": {
        "description": "It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script.",
        "signature": "_pgs_key_exists(key-id)",
        "snippet_string": "_pgs_key_exists( ${1:key-id} )"
    },
    "_pgs_set_key_val": {
        "description": "It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script.",
        "signature": "_pgs_set_key_val(key-id,index,value)",
        "snippet_string": "_pgs_set_key_val( ${1:key-id}, ${2:index}, ${3:value} )"
    },
    "_read_persistent_var": {
        "description": "instantly reloads the value of a variable that was saved via the make_persistent()command",
        "signature": "_read_persistent_var(variable)",
        "snippet_string": "_read_persistent_var( ${1:variable} )"
    },
    "_reset_rls_trig_counter": {
        "description": "dresets the release trigger counter (used by the release trigger system script)",
        "signature": "_reset_rls_trig_counter(note)",
        "snippet_string": "_reset_rls_trig_counter( ${1:note} )"
    },
    "_set_engine_par": {
        "description": "control automatable KONTAKT parameters and bypass buttons",
        "signature": "_set_engine_par(parameter,value,group,slot,generic)",
        "snippet_string": "_set_engine_par( ${1:parameter}, ${2:value}, ${3:group}, ${4:slot}, ${5:generic} )"
    },
    "_set_skin_offset": {
        "description": "offsets the chosen background picture file by the specified number of pixels",
        "signature": "_set_skin_offset(offset-in-pixel)",
        "snippet_string": "_set_skin_offset( ${1:offset-in-pixel} )"
    },
    "_slice_idx_loop_end": {
        "description": "returns the index number of the slice at the loop end",
        "signature": "_slice_idx_loop_end(zone-ID,loop-index)",
        "snippet_string": "_slice_idx_loop_end( ${1:zone-ID}, ${2:loop-index} )"
    },
    "_slice_idx_loop_start": {
        "description": "returns the index number of the slice at the loop start",
        "signature": "_slice_idx_loop_start(zone-ID,loop-index)",
        "snippet_string": "_slice_idx_loop_start( ${1:zone-ID}, ${2:loop-index} )"
    },
    "_slice_length": {
        "description": "returns the length in microseconds of the specified slice with respect to the current tempo",
        "signature": "_slice_length(zone-ID,slice-index)",
        "snippet_string": "_slice_length( ${1:zone-ID}, ${2:slice-index} )"
    },
    "_slice_loop_count": {
        "description": "returns the loop count of the specified loop",
        "signature": "_slice_loop_count(zone-ID,loop-index)",
        "snippet_string": "_slice_loop_count( ${1:zone-ID}, ${2:loop-index} )"
    },
    "_slice_start": {
        "description": "returns the absolute start point of the specified slice in microseconds, independent of the current tempo",
        "signature": "_slice_start(zone-ID,slice-index)",
        "snippet_string": "_slice_start( ${1:zone-ID}, ${2:slice-index} )"
    },
    "_will_never_terminate": {
        "description": "",
        "signature": "_will_never_terminate(event-id)",
        "snippet_string": "_will_never_terminate( ${1:event-id} )"
    },
    "abs": {
        "description": "Absolute value",
        "signature": "abs(x)",
        "snippet_string": "abs( ${1:x} )"
    },
    "acos": {
        "description": "arccosine function",
        "signature": "acos(x)",
        "snippet_string": "acos( ${1:x} )"
    },
    "add_menu_item": {
        "description": "create a menu entry",
        "signature": "add_menu_item(variable,text,value)",
        "snippet_string": "add_menu_item( ${1:variable}, ${2:text}, ${3:value} )"
    },
    "add_text_line": {
        "description": "add a new text line in the specified label without erasing existing text",
        "signature": "add_text_line(variable,text)",
        "snippet_string": "add_text_line( ${1:variable}, ${2:text} )"
    },
    "allow_group": {
        "description": "allows the specified group, i.e. makes it available for playback",
        "signature": "allow_group(group-index)",
        "snippet_string": "allow_group( ${1:group-index} )"
    },
    "array_equal": {
        "description": "checks the values of two arrays, true if all values are equal, false if not",
        "signature": "array_equal(array-variable,array-variable)",
        "snippet_string": "array_equal( ${1:array-variable}, ${2:array-variable} )"
    },
    "asin": {
        "description": "arcsine (inverse sine function)",
        "signature": "asin(x)",
        "snippet_string": "asin( ${1:x} )"
    },
    "atan": {
        "description": "arctangent (inverse tangent function)",
        "signature": "atan(x)",
        "snippet_string": "atan( ${1:x} )"
    },
    "attach_level_meter": {
        "description": "attach a level meter to a certain position within the instrument to read volume data",
        "signature": "attach_level_meter(ui-ID,group,slot,channel,bus)",
        "snippet_string": "attach_level_meter( ${1:ui-ID}, ${2:group}, ${3:slot}, ${4:channel}, ${5:bus} )"
    },
    "attach_zone": {
        "description": "connects the corresponding zone to the waveform so that it shows up within the display",
        "signature": "attach_zone(variable,zone-id,flags)",
        "snippet_string": "attach_zone( ${1:variable}, ${2:zone-id}, ${3:flags} )"
    },
    "bitwise_and": {
        "description": "Bitwise Operator: \"and\"",
        "signature": "x .and. y",
        "snippet_string": "${1:x} .and. ${2:y}"
    },
    "bitwise_not": {
        "description": "Bitwise Operator: \"negation\"",
        "signature": ".not. x",
        "snippet_string": ".not. ${1:x}"
    },
    "bitwise_or": {
        "description": "Bitwise Operator: \"or\"",
        "signature": "x .or. y",
        "snippet_string": "${1:x} .or. ${2:y}"
    },
    "by_marks": {
        "description": "a user defined group of events (or event IDs)",
        "signature": "by_marks(bit-mask)",
        "snippet_string": "by_marks( ${1:bit-mask} )"
    },
    "by_track": {
        "description": "can be used to group events by their track number",
        "signature": "by_track(track)",
        "snippet_string": "by_track( ${1:track} )"
    },
    "call": {
        "description": "calls a previously declares function",
        "signature": "call functionName",
        "snippet_string": "call ${1:functionName}"
    },
    "cbrt": {
        "description": "Cube root function",
        "signature": "cbrt(x)",
        "snippet_string": "cbrt( ${1:x} )"
    },
    "cc_delivery_request": {
        "description": "Undocumented",
        "signature": "cc_delivery_request(arg1)",
        "snippet_string": "cc_delivery_request( ${1:arg1} )"
    },
    "ceil": {
        "description": "ceiling (round up) ceil(2.3) = 3.0",
        "signature": "ceil(x)",
        "snippet_string": "ceil( ${1:x} )"
    },
    "change_listener_par": {
        "description": "changes the parameters of the on listener callback. Can be used in every callback.",
        "signature": "change_listener_par(signal-type,parameter)",
        "snippet_string": "change_listener_par( ${1:signal-type}, ${2:parameter} )"
    },
    "change_note": {
        "description": "change the note number of a specific note event",
        "signature": "change_note(ID-number,note-number)",
        "snippet_string": "change_note( ${1:ID-number}, ${2:note-number} )"
    },
    "change_pan": {
        "description": "change the pan position of a specific note event",
        "signature": "change_pan(ID-number,panorama,relative-bit)",
        "snippet_string": "change_pan( ${1:ID-number}, ${2:panorama}, ${3:relative-bit} )"
    },
    "change_time_with_pitch": {
        "description": "Undocumented",
        "signature": "change_time_with_pitch(arg1)",
        "snippet_string": "change_time_with_pitch( ${1:arg1} )"
    },
    "change_tune": {
        "description": "change the tuning of a specific note event in millicent",
        "signature": "change_tune(ID-number,tune-amount,relative-bit)",
        "snippet_string": "change_tune( ${1:ID-number}, ${2:tune-amount}, ${3:relative-bit} )"
    },
    "change_velo": {
        "description": "change the velocity of a specific note event",
        "signature": "change_velo(ID-number,velocity)",
        "snippet_string": "change_velo( ${1:ID-number}, ${2:velocity} )"
    },
    "change_vol": {
        "description": "change the volume of a specific note event in millidecibel",
        "signature": "change_vol(ID-number,volume,relative-bit)",
        "snippet_string": "change_vol( ${1:ID-number}, ${2:volume}, ${3:relative-bit} )"
    },
    "connect_view": {
        "description": "Undocumented",
        "signature": "connect_view()",
        "snippet_string": "connect_view()"
    },
    "cos": {
        "description": "cosine function",
        "signature": "cos(x)",
        "snippet_string": "cos( ${1:x} )"
    },
    "dec": {
        "description": "decrement an expression by 1 (x - 1)",
        "signature": "dec(x)",
        "snippet_string": "dec( ${1:x} )"
    },
    "delete_event_mark": {
        "description": "delete an event mark, i.e. ungroup the specified event from an event group",
        "signature": "delete_event_mark(ID-number,bit-mark)",
        "snippet_string": "delete_event_mark( ${1:ID-number}, ${2:bit-mark} )"
    },
    "detect_drum_type": {
        "description": "Assigns <drum-type-result> a $NI_DETECT_DRUM_TYPE tag describing the drum type of an audio sample.",
        "signature": "detect_drum_type(zone-id,drum-type-result)",
        "snippet_string": "detect_drum_type( ${1:zone-id}, ${2:drum-type-result} )"
    },
    "detect_instrument_type": {
        "description": "Assigns <drum-type-result> a $NI_DETECT_INSTRUMENT_TYPE tag describing the in- strument type of an audio sample.",
        "signature": "detect_instrument_type(zone-id,instrument-type-result)",
        "snippet_string": "detect_instrument_type( ${1:zone-id}, ${2:instrument-type-result} )"
    },
    "detect_loudness": {
        "description": "Returns a real value representing the loudness of an audio sample in dB.",
        "signature": "detect_loudness(zone-id,loudness-result)",
        "snippet_string": "detect_loudness( ${1:zone-id}, ${2:loudness-result} )"
    },
    "detect_peak": {
        "description": "Returns a real value representing peak level of an audio sample in dB.",
        "signature": "detect_peak(zone-id,peak-result)",
        "snippet_string": "detect_peak( ${1:zone-id}, ${2:peak-result} )"
    },
    "detect_pitch": {
        "description": "Returns a real value representing the fundamental frequency of an audio sample, in semi- tones and cents",
        "signature": "detect_pitch(zone-id,pitch-result)",
        "snippet_string": "detect_pitch( ${1:zone-id}, ${2:pitch-result} )"
    },
    "detect_rms": {
        "description": "Returns a real value representing the RMS level of an audio sample in dB.",
        "signature": "detect_rms(zone-id,rms-result)",
        "snippet_string": "detect_rms( ${1:zone-id}, ${2:rms-result} )"
    },
    "detect_sample_type": {
        "description": "Assigns <sample-type-result> a $NI_DETECT_SAMPLE_TYPE tag describing the whether an audio sample is a drum or an instrument.",
        "signature": "detect_sample_type(zone-id,sample-type-result)",
        "snippet_string": "detect_sample_type( ${1:zone-id}, ${2:sample-type-result} )"
    },
    "disable_logging": {
        "description": "Quickly disabling emission of messages, warnings or watched variable\nevents to both the Kontakt Status Bar\n$NI_LOG_MESSAGE, $NI_LOG_WARNING, $NI_LOG_WATCHING\n",
        "signature": "disable_logging(type)",
        "snippet_string": "disable_logging( ${1:type} )"
    },
    "disallow_group": {
        "description": "disallows the specified group, i.e. makes it unavailable for playback",
        "signature": "disallow_group(group-index)",
        "snippet_string": "disallow_group( ${1:group-index} )"
    },
    "dont_use_machine_mode": {
        "description": "play the specified event in sampler mode",
        "signature": "dont_use_machine_mode(ID-number)",
        "snippet_string": "dont_use_machine_mode( ${1:ID-number} )"
    },
    "event_status": {
        "description": "retrieve the status of a particular note event (or MIDI event in the multi script)",
        "signature": "event_status(ID-number)",
        "snippet_string": "event_status( ${1:ID-number} )"
    },
    "exit": {
        "description": "immediately stops a callback or exits a function",
        "signature": "exit",
        "snippet_string": "exit"
    },
    "exp": {
        "description": "exponential function (returns the value of e^x)",
        "signature": "exp(x)",
        "snippet_string": "exp( ${1:x} )"
    },
    "fade_in": {
        "description": "perform a fade-in for a specific note event",
        "signature": "fade_in(ID-number,fade-time)",
        "snippet_string": "fade_in( ${1:ID-number}, ${2:fade-time} )"
    },
    "fade_out": {
        "description": "perform a fade-out for a specific note event",
        "signature": "fade_out(ID-number,fade-time)",
        "snippet_string": "fade_out( ${1:ID-number}, ${2:fade-time} )"
    },
    "find_group": {
        "description": "returns the group index for the specified group name",
        "signature": "find_group(group-name)",
        "snippet_string": "find_group( ${1:group-name} )"
    },
    "find_mod": {
        "description": "returns the slot index of an internal modulator or external modulation slot",
        "signature": "find_mod(group-index,mod-name)",
        "snippet_string": "find_mod( ${1:group-index}, ${2:mod-name} )"
    },
    "find_target": {
        "description": "returns the slot index of a modulation slot of an internal modulator",
        "signature": "find_target(group-index,mod-index,target-name)",
        "snippet_string": "find_target( ${1:group-index}, ${2:mod-index}, ${3:target-name} )"
    },
    "find_zone": {
        "description": "returns the zone ID for the specified zone name. Only availabe in the init callback.",
        "signature": "find_zone(zone-name)",
        "snippet_string": "find_zone( ${1:zone-name} )"
    },
    "floor": {
        "description": "floor (round down) floor(2.8) = 2.0",
        "signature": "floor(x)",
        "snippet_string": "floor( ${1:x} )"
    },
    "fs_get_filename": {
        "description": "return the filename of the last selected file in the UI file browser.",
        "signature": "fs_get_filename(ui-ID,return-parameter)",
        "snippet_string": "fs_get_filename( ${1:ui-ID}, ${2:return-parameter} )"
    },
    "fs_navigate": {
        "description": "jump to the next/previous file in an ui file selector and trigger its callback.",
        "signature": "fs_navigate(ui-ID,direction)",
        "snippet_string": "fs_navigate( ${1:ui-ID}, ${2:direction} )"
    },
    "function": {
        "description": "declares a function",
        "signature": "",
        "snippet_string": ""
    },
    "get_control_par": {
        "description": "retrieve various parameters of the specified gui control",
        "signature": "get_control_par(ui-ID,control-parameter)",
        "snippet_string": "get_control_par( ${1:ui-ID}, ${2:control-parameter} )"
    },
    "get_control_par_arr": {
        "description": "Undocumented",
        "signature": "get_control_par_arr(arg1,arg2},arg3)",
        "snippet_string": "get_control_par_arr( ${1:arg1}, ${2:arg2}, ${3:arg3} )"
    },
    "get_control_par_real_arr": {
        "description": "Undocumented",
        "signature": "get_control_par_real_arr(arg1,arg2},arg3)",
        "snippet_string": "get_control_par_real_arr( ${1:arg1}, ${2:arg2}, ${3:arg3} )"
    },
    "get_control_par_str": {
        "description": "Undocumented",
        "signature": "get_control_par_str(arg1},arg2)",
        "snippet_string": "get_control_par_str( ${1:arg1}, ${2:arg2} )"
    },
    "get_control_par_str_arr": {
        "description": "Undocumented",
        "signature": "get_control_par_str(arg1},arg2,arg3)",
        "snippet_string": "get_control_par_str_arr( ${1:arg1}, ${2:arg2}, ${3:arg3} )"
    },
    "get_engine_par": {
        "description": "returns the value of a specific engine parameter",
        "signature": "get_engine_par(parameter,group,slot,generic)",
        "snippet_string": "get_engine_par( ${1:parameter}, ${2:group}, ${3:slot}, ${4:generic} )"
    },
    "get_engine_par_disp": {
        "description": "returns the displayed string of a specific engine parameter",
        "signature": "get_engine_par_disp(parameter,group,slot,generic)",
        "snippet_string": "get_engine_par_disp( ${1:parameter}, ${2:group}, ${3:slot}, ${4:generic} )"
    },
    "get_engine_par_disp_m": {
        "description": "Undocumented",
        "signature": "get_engine_par_disp_m(arg1,arg2},arg3,arg4)",
        "snippet_string": "get_engine_par_disp_m( ${1:arg1}, ${2:arg2}, ${3:arg3}, ${4:arg4} )"
    },
    "get_engine_par_m": {
        "description": "Undocumented",
        "signature": "get_engine_par_m(arg1,arg2,arg3,arg4)",
        "snippet_string": "get_engine_par_m( ${1:arg1}, ${2:arg2}, ${3:arg3}, ${4:arg4} )"
    },
    "get_event_ids": {
        "description": "fills the specified array with all active event IDs.",
        "signature": "get_event_ids(array-name)",
        "snippet_string": "get_event_ids( ${1:array-name} )"
    },
    "get_event_mark": {
        "description": "Check if the specified event belongs to a specific event group (returns 1 if the bitmark is set, 0 otherwise)",
        "signature": "get_event_mark(ID-number,bit-mark)",
        "snippet_string": "get_event_mark( ${1:ID-number}, ${2:bit-mark} )"
    },
    "get_event_par": {
        "description": "return the value of a specific event parameter of the specified event",
        "signature": "get_event_par(ID-number,parameter)",
        "snippet_string": "get_event_par( ${1:ID-number}, ${2:parameter} )"
    },
    "get_event_par_arr": {
        "description": "special form of get_event_par(), used to retrieve the group allow state of the specified event",
        "signature": "get_event_par_arr(ID-number,parameter,group-index)",
        "snippet_string": "get_event_par_arr( ${1:ID-number}, ${2:parameter}, ${3:group-index} )"
    },
    "get_folder": {
        "description": "returns the path specified with the built-in path variable",
        "signature": "get_folder(path-variable)",
        "snippet_string": "get_folder( ${1:path-variable} )"
    },
    "get_font_id": {
        "description": "Enables use of custom dynamic fonts",
        "signature": "get_font_id(id)",
        "snippet_string": "get_font_id( ${1:id} )"
    },
    "get_group_idx": {
        "description": "returns the group index for the specified group name",
        "signature": "get_group_idx(group-name)",
        "snippet_string": "get_group_idx( ${1:group-name} )"
    },
    "get_key_color": {
        "description": "returns the color constant of the specified note number",
        "signature": "get_key_color(note-nr)",
        "snippet_string": "get_key_color( ${1:note-nr} )"
    },
    "get_key_name": {
        "description": "returns the name of the specified key",
        "signature": "get_key_name(note-nr)",
        "snippet_string": "get_key_name( ${1:note-nr} )"
    },
    "get_key_triggerstate": {
        "description": "returns the pressed state of the specified note number (i.e. key) on the KONTAKT keyboard, can be either 1 (key pressed) or 0 (key released)",
        "signature": "get_key_triggerstate(note-nr)",
        "snippet_string": "get_key_triggerstate( ${1:note-nr} )"
    },
    "get_key_type": {
        "description": "returns the key type constant of the specified key.",
        "signature": "get_key_type(note-nr)",
        "snippet_string": "get_key_type( ${1:note-nr} )"
    },
    "get_keyrange_max_note": {
        "description": "returns the highest note of the specified key range",
        "signature": "get_keyrange_max_note(note-nr)",
        "snippet_string": "get_keyrange_max_note( ${1:note-nr} )"
    },
    "get_keyrange_min_note": {
        "description": "returns the lowest note of the specified key range",
        "signature": "get_keyrange_min_note(note-nr)",
        "snippet_string": "get_keyrange_min_note( ${1:note-nr} )"
    },
    "get_keyrange_name": {
        "description": "returns the name of the specified key range",
        "signature": "get_keyrange_name(note-nr)",
        "snippet_string": "get_keyrange_name( ${1:note-nr} )"
    },
    "get_loop_par": {
        "description": "Returns the loop parameters of a zone",
        "signature": "get_loop_par(zone-id,loop_index,parameter)",
        "snippet_string": "get_loop_par( ${1:zone-id}, ${2:loop-index}, ${3:parameter} )"
    },
    "get_loop_sample": {
        "description": "Returns paths, file names and extensions of samples",
        "signature": "get_sample(zone-id,return-parameter)",
        "snippet_string": "get_loop_par( ${1:zone-id}, ${2:return-parameter} )"
    },
    "get_menu_item_str": {
        "description": "returns the string value of the menu's entry.",
        "signature": "get_menu_item_str(menu-ID,index)",
        "snippet_string": "get_menu_item_str( ${1:menu-ID}, ${2:index} )"
    },
    "get_menu_item_value": {
        "description": "returns the value of the menu's entry.",
        "signature": "get_menu_item_value(menu-ID,index)",
        "snippet_string": "get_menu_item_value( ${1:menu-ID}, ${2:index} )"
    },
    "get_menu_item_visibility": {
        "description": "returns 1 if the menu entry is visible, otherwise 0.",
        "signature": "get_menu_item_visibility(menu-ID,index)",
        "snippet_string": "get_menu_item_visibility( ${1:menu-ID}, ${2:index} )"
    },
    "get_mod_idx": {
        "description": "Returns the slot index of an internal modulator or external modulation slot",
        "signature": "get_mod_idx(group-index,mod-name)",
        "snippet_string": "get_mod_idx( ${1:group-index}, ${2:mod-name} )"
    },
    "get_num_zones": {
        "description": "Returns the total number of all zones that are present in the instrument (regular and user zones)",
        "signature": "get_num_zones()",
        "snippet_string": "get_num_zones()"
    },
    "get_purge_state": {
        "description": "returns the purge state of the specified group. 0=purged, 1=not purged",
        "signature": "get_purge_state(group-index)",
        "snippet_string": "get_purge_state( ${1:group-index} )"
    },
    "get_sample_length": {
        "description": "returns the length of the specified zone's sample in microseconds",
        "signature": "get_sample_length(zone-ID)",
        "snippet_string": "get_sample_length( ${1:zone-ID} )"
    },
    "get_sel_zones_idx": {
        "description": "Fills the specified array with indices of all selected zones in KONTAKT's Mapping Editor.",
        "signature": "get_sel_zones_idx(array-name)",
        "snippet_string": "get_sel_zones_idx( ${1:array-name} )"
    },
    "get_target_idx": {
        "description": "Returns the modulation target slot index of an internal modulator",
        "signature": "get_target_idx(group-index,mod-index,target-name)",
        "snippet_string": "get_target_idx( ${1:group-index}, ${2:mod-index}, ${3:target-name} )"
    },
    "get_ui_id": {
        "description": "retrieve the ID number of an ui control",
        "signature": "get_ui_id(variable)",
        "snippet_string": "get_ui_id( ${1:variable} )"
    },
    "get_ui_wf_property": {
        "description": "returns the value of the waveform's different properties.",
        "signature": "get_ui_wf_property(variable,property,index)",
        "snippet_string": "get_ui_wf_property( ${1:variable}, ${2:property}, ${3:index} )"
    },
    "get_voice_limit": {
        "description": "retunrs the voice limit for the Time Machine Pro mode of the source module",
        "signature": "get_voice_limit(voice-type)",
        "snippet_string": "get_voice_limit( ${1:voice-type} )"
    },
    "get_zone_id": {
        "description": "Returns the ID of the zone with the specified zone index",
        "signature": "get_zone_id(zone-index)",
        "snippet_string": "get_zone_id( ${1:zone-index} )"
    },
    "get_zone_par": {
        "description": "Returns the zone parameters",
        "signature": "get_zone_par(zone-id,parameter)",
        "snippet_string": "get_zone_par( ${1:zone-id}, ${2:parameter} )"
    },
    "get_zone_status": {
        "description": "Queries the status of the zone ID in question. Zone status has four possible states:\n- $NI_ZONE_STATUS_EMPTY - zone is a user zone and has no sample loaded\n- $NI_ZONE_STATUS_LOADED - zone is a user zone and has a sample loaded\n- $NI_ZONE_STATUS_PURGED - zone is purged from memory (valid for both regular and user\nzones)\n- $NI_ZONE_STATUS_IGNORED - zone is ignored by the user response in the Content Missing\ndialog (valid for both regular and user zones)\n",
        "signature": "get_zone_status(zone-id)",
        "snippet_string": "get_zone_status( ${1:zone-id} )"
    },
    "group_name": {
        "description": "returns the group name for the specified group",
        "signature": "group_name(group-index)",
        "snippet_string": "group_name( ${1:group-index} )"
    },
    "hide_part": {
        "description": "hide specific parts of user interface controls",
        "signature": "hide_part(variable,hide-mask)",
        "snippet_string": "hide_part( ${1:variable}, ${2:hide-mask} )"
    },
    "ignore_controller": {
        "description": "ignore a controller event in a controller callback",
        "signature": "ignore_controller",
        "snippet_string": "ignore_controller"
    },
    "ignore_event": {
        "description": "ignore a note event in a note on or note off callback",
        "signature": "ignore_event(ID-number)",
        "snippet_string": "ignore_event( ${1:ID-number} )"
    },
    "ignore_midi": {
        "description": "Like ignore_event(), ignore_midi is a very \"strong\" command. Keep in mind that ignore_midi will ignore all incoming MIDI events. If you simply want to change the MIDI channel and/or any of the MIDI bytes, you can also use set_event_par().",
        "signature": "ignore_midi",
        "snippet_string": "ignore_midi"
    },
    "in_range": {
        "description": "Boolean Operator: true if x is between y and z",
        "signature": "in_range(x,y,z)",
        "snippet_string": "in_range( ${1:x}, ${2:y}, ${3:z} )"
    },
    "inc": {
        "description": "increment an expression by 1 (x + 1)",
        "signature": "inc(x)",
        "snippet_string": "inc( ${1:x} )"
    },
    "int": {
        "description": "converts an integer value into a real number",
        "signature": "int(real)",
        "snippet_string": "int( ${1:real value} )"
    },
    "int_to_real": {
        "description": "converts an integer value into a real number",
        "signature": "int_to_real(integer)",
        "snippet_string": "int_to_real( ${1:integer value} )"
    },
    "is_zone_empty": {
        "description": "Returns 1 if a zone is empty (has no sample), otherwise returns 0",
        "signature": "is_zone_empty(zone-id)",
        "snippet_string": "is_zone_emptyr( ${1:zone-id} )"
    },
    "load_array": {
        "description": "loads an array from an external file (.nka file)",
        "signature": "load_array(array-variable,mode)",
        "snippet_string": "load_array( ${1:array-variable}, ${2:mode} )"
    },
    "load_array_str": {
        "description": "loads an array from an external file (.nka file) using the file's absolute path",
        "signature": "load_array_str(array-variable,path)",
        "snippet_string": "load_array_str( ${1:array-variable}, ${2:path} )"
    },
    "load_ir_sample": {
        "description": "loads an impulse response sample into KONTAKT's convolution effect",
        "signature": "load_ir_sample(file-path,slot,generic)",
        "snippet_string": "load_ir_sample( ${1:file-path}, ${2:slot}, ${3:generic} )"
    },
    "load_ir_sample_m": {
        "description": "Undocumented",
        "signature": "load_ir_sample_m(arg1)",
        "snippet_string": "load_ir_sample_m( ${1:arg1} )"
    },
    "load_midi_file": {
        "description": "Load MIDI file from path (*Non documented)",
        "signature": "load_midi_file(path)",
        "snippet_string": "load_midi_file( ${1:path} )"
    },
    "load_patch": {
        "description": "Undocumented",
        "signature": "load_patch(arg1,arg2)",
        "snippet_string": "load_patch( ${1:arg1}, ${2:arg2} )"
    },
    "load_performance_view": {
        "description": "Loads a performance view file (NCKP) that was created in the Creator Tools GUI Designer <filename>. The filename of the NCKP file, without extension, as a string (in quotation marks)",
        "signature": "load_performance_view(filename)",
        "snippet_string": "load_performance_view( ${1:filename} )"
    },
    "log": {
        "description": "logarithmic function",
        "signature": "log(x)",
        "snippet_string": "log( ${1:x} )"
    },
    "lsb": {
        "description": "return the LSB portion (least significant byte) of a 14 bit value",
        "signature": "lsb(value)",
        "snippet_string": "lsb( ${1:value} )"
    },
    "make_instr_persistence": {
        "description": "retain the value of a variable only with the instrument",
        "signature": "make_instr_persistence(variable)",
        "snippet_string": "make_instr_persistence( ${1:variable} )"
    },
    "make_instr_persistent": {
        "description": "retain the value of a variable only with the instrument",
        "signature": "make_instr_persistent(variable)",
        "snippet_string": "make_instr_persistent( ${1:variable} )"
    },
    "make_perfview": {
        "description": "activates the performance view for the respective script",
        "signature": "make_perfview",
        "snippet_string": "make_perfview"
    },
    "make_persistent": {
        "description": "retain the value of a variable whith the instrument and snapshot",
        "signature": "make_persistent(variable)",
        "snippet_string": "make_persistent( ${1:variable} )"
    },
    "message": {
        "description": "display text in the status line of KONTAKT",
        "signature": "message(variable/text)",
        "snippet_string": "message( ${1:variable/text} )"
    },
    "mf_copy_export_area": {
        "description": "Copies the content of MIDI export area 0 to the specified index.",
        "signature": "mf_insert_file(index)",
        "snippet_string": "mf_copy_export_area( ${1:index} )"
    },
    "mf_get_buffer_size": {
        "description": "returns the size of the MIDI event buffer",
        "signature": "mf_get_buffer_size()",
        "snippet_string": "mf_get_buffer_size()"
    },
    "mf_get_byte_one": {
        "description": "Undocumented",
        "signature": "mf_get_byte_one()",
        "snippet_string": "mf_get_byte_one()"
    },
    "mf_get_byte_two": {
        "description": "Undocumented",
        "signature": "mf_get_byte_two()",
        "snippet_string": "mf_get_byte_two()"
    },
    "mf_get_channel": {
        "description": "Undocumented",
        "signature": "mf_get_channel()",
        "snippet_string": "mf_get_channel()"
    },
    "mf_get_command": {
        "description": "Undocumented",
        "signature": "mf_get_command()",
        "snippet_string": "mf_get_command()"
    },
    "mf_get_event_par": {
        "description": "returns the value of an event parameter",
        "signature": "mf_get_event_par(event-id,parameter)",
        "snippet_string": "mf_get_event_par( ${1:event-id}, ${2:parameter} )"
    },
    "mf_get_first": {
        "description": "moves the position marker to the first event in the MIDI track",
        "signature": "mf_get_first(track-index)",
        "snippet_string": "mf_get_first( ${1:track-index} )"
    },
    "mf_get_id": {
        "description": "returns the ID of the currently selected event (when using the navigation commands like mf_get_first(), and mf_get_next(), etc)",
        "signature": "mf_get_id()",
        "snippet_string": "mf_get_id()"
    },
    "mf_get_last": {
        "description": "moves the position marker to the last event in the MIDI track",
        "signature": "mf_get_last(track-index)",
        "snippet_string": "mf_get_last( ${1:track-index} )"
    },
    "mf_get_last_filename": {
        "description": "Returns the filename (not the full path!) of the last MIDI file that was inserted into KONTAKT, either via mf_insert_file(), or via drag and drop operation on ui_mouse_area.",
        "signature": "mf_get_last_filename()",
        "snippet_string": "mf_get_last_filename()"
    },
    "mf_get_mark": {
        "description": "checks if an event is marked or not. Returns 1 if it is marked, or 0 if it is not.",
        "signature": "mf_get_mark(event-id,mark)",
        "snippet_string": "mf_get_mark( ${1:event-id}, ${2:mark} )"
    },
    "mf_get_next": {
        "description": "moves the position marker to the next event in the MIDI track",
        "signature": "mf_get_next(track-index)",
        "snippet_string": "mf_get_next( ${1:track-index} )"
    },
    "mf_get_next_at": {
        "description": "moves the position marker to the next event in the MIDI track right after the defined position.",
        "signature": "mf_get_next_at(track-index,pos)",
        "snippet_string": "mf_get_next_at( ${1:track-index}, ${2:pos} )"
    },
    "mf_get_note_length": {
        "description": "Undocumented",
        "signature": "mf_get_note_length()",
        "snippet_string": "mf_get_note_length()"
    },
    "mf_get_num_tracks": {
        "description": "returns the number of tracks in a MIDI object.",
        "signature": "mf_get_num_tracks()",
        "snippet_string": "mf_get_num_tracks()"
    },
    "mf_get_pos": {
        "description": "Undocumented",
        "signature": "mf_get_pos()",
        "snippet_string": "mf_get_pos()"
    },
    "mf_get_prev": {
        "description": "moves the position marker to the previous event in the MIDI track",
        "signature": "mf_get_prev(track-index)",
        "snippet_string": "mf_get_prev( ${1:track-index} )"
    },
    "mf_get_prev_at": {
        "description": "moves the position marker to the first event before the defined position",
        "signature": "mf_get_prev_at(track-index,pos)",
        "snippet_string": "mf_get_prev_at( ${1:track-index}, ${2:pos} )"
    },
    "mf_get_track_idx": {
        "description": "Undocumented",
        "signature": "mf_get_track_idx()",
        "snippet_string": "mf_get_track_idx()"
    },
    "mf_insert_event": {
        "description": "activates an inactive MIDI event in the MIDI object. However, because the command and position are defined in this command, it can be considered as an insertion.",
        "signature": "mf_insert_event(track,pos,command,byte1,byte2)",
        "snippet_string": "mf_insert_event( ${1:track}, ${2:pos}, ${3:command}, ${4:byte1}, ${5:byte2} )"
    },
    "mf_insert_file": {
        "description": "inserts a MIDI file into the MIDI object.",
        "signature": "mf_insert_file(path,track-offset,position-offset,mode)",
        "snippet_string": "mf_insert_file( ${1:path}, ${2:track-offset}, ${3:position-offset}, ${4:mode} )"
    },
    "mf_remove_event": {
        "description": "deactivates an event in the MIDI object, effectively removing it",
        "signature": "mf_remove_event(event-id)",
        "snippet_string": "mf_remove_event( ${1:event-id} )"
    },
    "mf_reset": {
        "description": "resets the MIDI object, sets the event buffer to zero, and removes all events",
        "signature": "mf_reset()",
        "snippet_string": "mf_reset()"
    },
    "mf_set_buffer_size": {
        "description": "defines a number of inactive MIDI events, that can be activated and edited",
        "signature": "mf_set_buffer_size(size)",
        "snippet_string": "mf_set_buffer_size( ${1:size} )"
    },
    "mf_set_byte_one": {
        "description": "Non documented",
        "signature": "mf_set_byte_one(value)",
        "snippet_string": "mf_set_byte_one( ${1:value} )"
    },
    "mf_set_byte_two": {
        "description": "Non documented",
        "signature": "mf_set_byte_two(value)",
        "snippet_string": "mf_set_byte_two( ${1:value} )"
    },
    "mf_set_channel": {
        "description": "Undocumented",
        "signature": "mf_set_channel()",
        "snippet_string": "mf_set_channel()"
    },
    "mf_set_command": {
        "description": "Non documented",
        "signature": "mf_set_command(value)",
        "snippet_string": "mf_set_command( ${1:value} )"
    },
    "mf_set_event_par": {
        "description": "sets an event parameter",
        "signature": "mf_set_event_par(event-id,parameter,value)",
        "snippet_string": "mf_set_event_par( ${1:event-id}, ${2:parameter}, ${3:value} )"
    },
    "mf_set_export_area": {
        "description": "defines the part of the MIDI object that will be exported when using a drag and drop area, or the save_midi_file() command.",
        "signature": "mf_set_export_area(name,start-pos,end-pos,start-track,end-track)",
        "snippet_string": "mf_set_export_area( ${1:name}, ${2:start-pos}, ${3:end-pos}, ${4:start-track}, ${5:end-track} )"
    },
    "mf_set_mark": {
        "description": "marks an event, so that you may groups events together and process that group quickly",
        "signature": "mf_set_mark(event-id,mark,status)",
        "snippet_string": "mf_set_mark( ${1:event-id}, ${2:mark}, ${3:status} )"
    },
    "mf_set_num_export_areas": {
        "description": "Sets the number of export areas, with a maximum of 512.",
        "signature": "mf_set_num_export_areas(num)",
        "snippet_string": "mf_set_num_export_areas( ${1:num} )"
    },
    "mf_set_pos": {
        "description": "Non documented",
        "signature": "mf_set_pos(value)",
        "snippet_string": "mf_set_pos( ${1:value} )"
    },
    "mod": {
        "description": "modulo; returns the remainder of a division",
        "signature": "x mod y",
        "snippet_string": "${1:x} mod ${2:y}"
    },
    "move_control": {
        "description": "position ui elements in the standard KONTAKT grid",
        "signature": "move_control(variable,x-position,y-position)",
        "snippet_string": "move_control( ${1:variable}, ${2:x-position}, ${3:y-position} )"
    },
    "move_control_px": {
        "description": "position ui elements in pixels",
        "signature": "move_control_px(variable,x-position,y-position)",
        "snippet_string": "move_control_px( ${1:variable}, ${2:x-position}, ${3:y-position} )"
    },
    "ms_to_ticks": {
        "description": "converts a microseconds value into a tempo dependent ticks value",
        "signature": "ms_to_ticks(microseconds)",
        "snippet_string": "ms_to_ticks( ${1:microseconds} )"
    },
    "msb": {
        "description": "return the MSB portion (most significant byte) of a 14 bit value",
        "signature": "msb(value)",
        "snippet_string": "msb( ${1:value} )"
    },
    "note_off": {
        "description": "send a note off message to a specific note",
        "signature": "note_off(ID-number)",
        "snippet_string": "note_off( ${1:ID-number} )"
    },
    "num_elements": {
        "description": "returns the number of elements in an array",
        "signature": "num_elements(array-variable)",
        "snippet_string": "num_elements( ${1:array-variable} )"
    },
    "num_slices": {
        "description": "Undocumented",
        "signature": "num_slices(arg1)",
        "snippet_string": "num_slices( ${1:arg1} )"
    },
    "num_slices_zone": {
        "description": "returns the number of slices of the specified zone",
        "signature": "num_slices_zone(zone-ID)",
        "snippet_string": "num_slices_zone( ${1:zone-ID} )"
    },
    "output_channel_name": {
        "description": "returns the channel name for the specified output",
        "signature": "output_channel_name(output-number)",
        "snippet_string": "output_channel_name( ${1:output-number} )"
    },
    "pgs_create_key": {
        "description": "It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script.",
        "signature": "pgs_create_key(key-id,size)",
        "snippet_string": "pgs_create_key( ${1:key-id}, ${2:size} )"
    },
    "pgs_create_str_key": {
        "description": "",
        "signature": "pgs_create_str_key(key-id)",
        "snippet_string": "pgs_create_str_key( ${1:key-id} )"
    },
    "pgs_get_key_val": {
        "description": "It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script.",
        "signature": "pgs_get_key_val(key-id,index)",
        "snippet_string": "pgs_get_key_val( ${1:key-id}, ${2:index} )"
    },
    "pgs_get_str_key_val": {
        "description": "Undocumented",
        "signature": "pgs_get_str_key_val()",
        "snippet_string": "pgs_get_str_key_val()"
    },
    "pgs_key_exists": {
        "description": "It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script.",
        "signature": "pgs_key_exists(key-id)",
        "snippet_string": "pgs_key_exists( ${1:key-id} )"
    },
    "pgs_set_key_val": {
        "description": "It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script.",
        "signature": "pgs_set_key_val(key-id,index,value)",
        "snippet_string": "pgs_set_key_val( ${1:key-id}, ${2:index}, ${3:value} )"
    },
    "pgs_set_str_key_val": {
        "description": "",
        "signature": "pgs_set_str_key_val(key-id,stringvalue)",
        "snippet_string": "pgs_set_str_key_val( ${1:key-id}, ${2:stringvalue} )"
    },
    "pgs_str_key_exists": {
        "description": "It is possible to send and receive values from one script to another, discarding the usual left-to-right order by using the Program Global Storage (PGS) commands. PGS is a dynamic memory that can be read/written by any script.",
        "signature": "pgs_str_key_exists(key-id)",
        "snippet_string": "pgs_str_key_exists( ${1:key-id} )"
    },
    "play_note": {
        "description": "generate a MIDI note, i.e. generate a note on message followed by a note off message",
        "signature": "play_note(note-number,velocity,sample-offset,duration)",
        "snippet_string": "play_note( ${1:note-number}, ${2:velocity}, ${3:sample-offset}, ${4:duration} )"
    },
    "pow": {
        "description": "power (returns the value of x^y)",
        "signature": "pow(x,y)",
        "snippet_string": "pow( ${1:x}, ${2:y} )"
    },
    "purge_group": {
        "description": "purges (i.e. unloads from RAM) the samples of the specified group",
        "signature": "purge_group(group-index,mode)",
        "snippet_string": "purge_group( ${1:group-index}, ${2:mode} )"
    },
    "random": {
        "description": "generate a random integer in the range <min> to <max>",
        "signature": "random(min,max)",
        "snippet_string": "random( ${1:min}, ${2:max} )"
    },
    "read_persistent_var": {
        "description": "instantly reloads the value of a variable that was saved via the make_persistent()command",
        "signature": "read_persistent_var(variable)",
        "snippet_string": "read_persistent_var( ${1:variable} )"
    },
    "real": {
        "description": "converts a real number into an integer",
        "signature": "real(integer)",
        "snippet_string": "real( ${1:integer value} )"
    },
    "real_to_int": {
        "description": "converts a real number into an integer",
        "signature": "real_to_int(real)",
        "snippet_string": "real_to_int( ${1:real value} )"
    },
    "redirect_midi": {
        "description": "Undocumented",
        "signature": "redirect_midi(arg1)",
        "snippet_string": "redirect_midi( ${1:arg1} )"
    },
    "redirect_output": {
        "description": "Routes the audio signal of the specified event to a specific output or bus",
        "signature": "redirect_output(ID-number,output-type,index)",
        "snippet_string": "redirect_output( ${1:ID-number}, ${2:output-type}, ${3:index} )"
    },
    "remove_keyrange": {
        "description": "assigns a text string to the specified range of keys",
        "signature": "remove_keyrange(note-nr)",
        "snippet_string": "remove_keyrange( ${1:note-nr} )"
    },
    "reset_engine": {
        "description": "Undocumented",
        "signature": "reset_engine()",
        "snippet_string": "reset_engine()"
    },
    "reset_ksp_timer": {
        "description": "resets the KSP timer ($KSP_TIMER) to zero",
        "signature": "reset_ksp_timer",
        "snippet_string": "reset_ksp_timer"
    },
    "reset_rls_trig_counter": {
        "description": "dresets the release trigger counter (used by the release trigger system script)",
        "signature": "reset_rls_trig_counter(note)",
        "snippet_string": "reset_rls_trig_counter( ${1:note} )"
    },
    "round": {
        "description": "round (round to nearest) round(2.3) = 2.0 round(2.8) = 3.0",
        "signature": "round(x)",
        "snippet_string": "round( ${1:x} )"
    },
    "save_array": {
        "description": "saves an array to an external file (i.e. an .nka file)",
        "signature": "save_array(array-variable,mode)",
        "snippet_string": "save_array( ${1:array-variable}, ${2:mode} )"
    },
    "save_array_str": {
        "description": "saves an array to an external file (i.e. an .nka file), using the specified absolute path",
        "signature": "save_array_str(array-variable,path)",
        "snippet_string": "save_array_str( ${1:array-variable}, ${2:path} )"
    },
    "save_midi_file": {
        "description": "saves a MIDI file with a range specified by the mf_set_export_area() command.",
        "signature": "save_midi_file(path)",
        "snippet_string": "save_midi_file( ${1:path} )"
    },
    "search": {
        "description": "searches the specified array for the specified value and returns the index of its first position.",
        "signature": "search(array-variable,value)",
        "snippet_string": "search( ${1:array-variable}, ${2:value} )"
    },
    "set_control_help": {
        "description": "assigns a text string to be displayed when hovering the ui control. The text will appear in KONTAKT's info pane.",
        "signature": "set_control_help(variable,text)",
        "snippet_string": "set_control_help( ${1:variable}, ${2:text} )"
    },
    "set_control_par": {
        "description": "change various parameters of the specified gui control",
        "signature": "set_control_par(ui-ID,control-parameter,value)",
        "snippet_string": "set_control_par( ${1:ui-ID}, ${2:control-parameter}, ${3:value} )"
    },
    "set_control_par_arr": {
        "description": "change various parameters of an element within an array based gui control (for example: cursors in the XY pad)",
        "signature": "set_control_par_arr(ui-ID,control-parameter,value,index)",
        "snippet_string": "set_control_par_arr( ${1:ui-ID}, ${2:control-parameter}, ${3:value}, ${4:index} )"
    },
    "set_control_par_str": {
        "description": "A variation of the command for usage with text strings. ( see: set_control_par() Remarks)",
        "signature": "set_control_par_str_arr(ui-ID,CONTROL_PAR_xxx,value)",
        "snippet_string": "set_control_par_str_arr( ${1:ui-ID}, ${2:CONTROL_PAR_xxx}, ${3:value} )"
    },
    "set_control_par_str_arr": {
        "description": "A variation of the command for usage with text strings. ( see: set_control_par_arr() Remarks)",
        "signature": "set_control_par_str_arr(ui-ID,control-parameter,value,index)",
        "snippet_string": "set_control_par_str_arr( ${1:ui-ID}, ${2:control-parameter}, ${3:value}, ${4:index} )"
    },
    "set_controller": {
        "description": "send a MIDI CC, pitchbend or channel pressure value",
        "signature": "set_controller(MIDI CC number/$VCC_PITCH_BEND/$VCC_MONO,value)",
        "snippet_string": "set_controller( ${1:MIDI CC number/$VCC_PITCH_BEND/$VCC_MONO}, ${2:value} )"
    },
    "set_engine_par": {
        "description": "control automatable KONTAKT parameters and bypass buttons",
        "signature": "set_engine_par(parameter,value,group,slot,generic)",
        "snippet_string": "set_engine_par( ${1:parameter}, ${2:value}, ${3:group}, ${4:slot}, ${5:generic} )"
    },
    "set_engine_par_m": {
        "description": "Undocumented",
        "signature": "set_engine_par_m(arg1,arg2,arg3,arg4,arg5)",
        "snippet_string": "set_engine_par_m( ${1:arg1}, ${2:arg2}, ${3:arg3}, ${4:arg4}, ${5:arg5} )"
    },
    "set_event_mark": {
        "description": "Assign the specified event to a specific event group",
        "signature": "set_event_mark(ID-number,bit-mark)",
        "snippet_string": "set_event_mark( ${1:ID-number}, ${2:bit-mark} )"
    },
    "set_event_par": {
        "description": "assign a parameter to a specific event",
        "signature": "set_event_par(ID-number,parameter,value)",
        "snippet_string": "set_event_par( ${1:ID-number}, ${2:parameter}, ${3:value} )"
    },
    "set_event_par_arr": {
        "description": "special form of set_event_par(), used to set the group allow state of the specified event",
        "signature": "set_event_par_arr(ID-number,parameter,value,group-index)",
        "snippet_string": "set_event_par_arr( ${1:ID-number}, ${2:parameter}, ${3:value}, ${4:group-index} )"
    },
    "set_key_color": {
        "description": "sets the color of the specified key (i.e. MIDI note) on the KONTAKT keyboard. use $KEY_COLOR_****",
        "signature": "set_key_color(note-nr,key-color-constant)",
        "snippet_string": "set_key_color( ${1:note-nr}, ${2:key-color-constant} )"
    },
    "set_key_name": {
        "description": "assigns a text string to the specified key",
        "signature": "set_key_name(note-nr,name)",
        "snippet_string": "set_key_name( ${1:note-nr}, ${2:name} )"
    },
    "set_key_pressed": {
        "description": "sets the trigger state of the specified key on KONTAKT's keyboard either to pressed/on (1) or released/off (0)",
        "signature": "set_key_pressed(note-nr,value)",
        "snippet_string": "set_key_pressed( ${1:note-nr}, ${2:value} )"
    },
    "set_key_pressed_support": {
        "description": "sets the pressed state support mode for KONTAKT'S keyboard. The available modes are:\n0: KONTAKT handles all pressed states, set_key_pressed() commands are ignored (default mode)\n1: KONTAKT's keyboard is only affected by set_key_pressed() commands\n",
        "signature": "set_key_pressed_support(mode)",
        "snippet_string": "set_key_pressed_support( ${1:mode} )"
    },
    "set_key_type": {
        "description": "assigns a key type to the specified key.\nThe following key types are available:\n$NI_KEY_TYPE_DEFAULT (i.e. normal mapped notes that produce sound)\n$NI_KEY_TYPE_CONTROL (i.e. key switches or other notes that do not produce sound)\n$NI_KEY_TYPE_NONE (resets the key to its normal KONTAKT behaviour)\n",
        "signature": "set_key_type(note-nr,key-type-constant)",
        "snippet_string": "set_key_type( ${1:note-nr}, ${2:key-type-constant} )"
    },
    "set_keyrange": {
        "description": "assigns a text string to the specified range of keys.",
        "signature": "set_keyrange(min-note,max-note,name)",
        "snippet_string": "set_keyrange( ${1:min-note}, ${2:max-note}, ${3:name} )"
    },
    "set_knob_defval": {
        "description": "assign a default value to a knob to which the knob is reset when Cmd-clicking (mac) or Ctrl-clicking (PC) the knob.",
        "signature": "set_knob_defval(variable,value)",
        "snippet_string": "set_knob_defval( ${1:variable}, ${2:value} )"
    },
    "set_knob_label": {
        "description": "assign a text string to a knob",
        "signature": "set_knob_label(variable,text)",
        "snippet_string": "set_knob_label( ${1:variable}, ${2:text} )"
    },
    "set_knob_unit": {
        "description": "assign a unit mark to a knob.",
        "signature": "set_knob_unit(variable,knob-unit-constant)",
        "snippet_string": "set_knob_unit( ${1:variable}, ${2:knob-unit-constant} )"
    },
    "set_listener": {
        "description": "Sets the signals on which the listener callback should react to. Can only be used in the init callback.",
        "signature": "set_listener(signal-type,parameter)",
        "snippet_string": "set_listener( ${1:signal-type}, ${2:parameter} )"
    },
    "set_loop_par": {
        "description": "Sets the loop parameters of a user zone",
        "signature": "set_loop_par(zone-id,loop_index,parameter,value)",
        "snippet_string": "set_loop_par( ${1:zone-id}, ${2:loop-index}, ${3:parameter}, ${4:value} )"
    },
    "set_map_editor_event_color": {
        "description": "Assigns the specified color to events generated in the current script slot, visible in KONTAKT's Mapping Editor.",
        "signature": "set_map_editor_event_color(hex-value)",
        "snippet_string": "set_map_editor_event_color( ${1:hex-value} )"
    },
    "set_menu_item_str": {
        "description": "sets the value of a menu entry.",
        "signature": "set_menu_item_str(menu-id,index,string)",
        "snippet_string": "set_menu_item_str( ${1:menu-id}, ${2:index}, ${3:string} )"
    },
    "set_menu_item_value": {
        "description": "sets the value of a menu entry.",
        "signature": "set_menu_item_value(menu-id,index,value)",
        "snippet_string": "set_menu_item_value( ${1:menu-id}, ${2:index}, ${3:value} )"
    },
    "set_menu_item_visibility": {
        "description": "sets the visibility of a menu entry.",
        "signature": "set_menu_item_visibility(menu-id,index,visibility)",
        "snippet_string": "set_menu_item_visibility( ${1:menu-id}, ${2:index}, ${3:visibility} )"
    },
    "set_midi": {
        "description": "create any type of MIDI event. If you simply want to change the MIDI channel and/or any of the MIDI bytes, you can also use set_event_par().",
        "signature": "set_midi(channel,command,byte1,byte2)",
        "snippet_string": "set_midi( ${1:channel}, ${2:command}, ${3:byte-1}, ${4:byte-2} )"
    },
    "set_nrpn": {
        "description": "send a nrpn message",
        "signature": "set_nrpn(address,value)",
        "snippet_string": "set_nrpn( ${1:address}, ${2:value} )"
    },
    "set_num_user_zones": {
        "description": "Creates empty user zones",
        "signature": "set_num_user_zones(number_of_user_zones)",
        "snippet_string": "set_num_user_zones(${1:number_of_user_zones} )"
    },
    "set_rpn": {
        "description": "send a rpn message",
        "signature": "set_rpn(address,value)",
        "snippet_string": "set_rpn( ${1:address}, ${2:value} )"
    },
    "set_sample": {
        "description": "Sets the user sample in a zone",
        "signature": "set_sample(zone-id,sample-path)",
        "snippet_string": "set_sample( ${1:zone-id}, ${2:sample-path} )"
    },
    "set_script_title": {
        "description": "set the script title",
        "signature": "set_script_title(text)",
        "snippet_string": "set_script_title( ${1:text} )"
    },
    "set_skin_offset": {
        "description": "offsets the chosen background picture file by the specified number of pixels",
        "signature": "set_skin_offset(offset-in-pixel)",
        "snippet_string": "set_skin_offset( ${1:offset-in-pixel} )"
    },
    "set_snapshot_type": {
        "description": "configures the KSP processor behavior of all five slots when a snapshot is recalled",
        "signature": "set_snapshot_type(type)",
        "snippet_string": "set_snapshot_type( ${1:type} )"
    },
    "set_table_steps_shown": {
        "description": "changes the number of displayed columns in an ui table",
        "signature": "set_table_steps_shown(variable,num-of-steps)",
        "snippet_string": "set_table_steps_shown( ${1:variable}, ${2:num-of-steps} )"
    },
    "set_text": {
        "description": "when applied to a label: delete the text currently visible in the specified label and add new text.\nwhen applied to knobs, buttons, switches and value edits: set the display name of the ui element.\n",
        "signature": "set_text(variable,text)",
        "snippet_string": "set_text( ${1:variable}, ${2:text} )"
    },
    "set_ui_color": {
        "description": "set the main background color of the performance view",
        "signature": "set_ui_color(hex-values,text)",
        "snippet_string": "set_ui_color( ${1:hex-values}, ${2:text} )"
    },
    "set_ui_height": {
        "description": "set the height of a script performance view in grid units",
        "signature": "set_ui_height(height)",
        "snippet_string": "set_ui_height( ${1:height} )"
    },
    "set_ui_height_px": {
        "description": "set the height of a script performance view in pixels",
        "signature": "set_ui_height_px(height)",
        "snippet_string": "set_ui_height_px( ${1:height} )"
    },
    "set_ui_wf_property": {
        "description": "sets different properties for the waveform control",
        "signature": "set_ui_wf_property(variable,property,index,value)",
        "snippet_string": "set_ui_wf_property( ${1:variable}, ${2:property}, ${3:index}, ${4:value} )"
    },
    "set_ui_width_px": {
        "description": "set the width of a script performance view in pixels",
        "signature": "set_ui_width_px(width)",
        "snippet_string": "set_ui_width_px( ${1:width} )"
    },
    "set_voice_limit": {
        "description": "sets the voice limit for the Time Machine Pro mode of the source module",
        "signature": "set_voice_limit(voice-type,value)",
        "snippet_string": "set_voice_limit( ${1:voice-type}, ${2:value} )"
    },
    "set_zone_par": {
        "description": "Sets the user zone parameters",
        "signature": "set_zone_par(zone-id,parameter,value)",
        "snippet_string": "set_zone_par( ${1:zone-id}, ${2:parameter}, ${3:value} )"
    },
    "sgn": {
        "description": "Signum function (returns -1 if the number is negative, 0 if it's zero, 1 if it's positive)",
        "signature": "sgn(x)",
        "snippet_string": "sgn( ${1:x} )"
    },
    "sh_left": {
        "description": "shifts the bits in <expression> by the amount of <shift-bits> to the left",
        "signature": "sh_left(expression,shift-bits)",
        "snippet_string": "sh_left( ${1:expression}, ${2:shift-bits} )"
    },
    "sh_right": {
        "description": "shifts the bits in <expression> by the amount of <shift-bits> to the right",
        "signature": "sh_right(expression,shift-bits)",
        "snippet_string": "sh_right( ${1:expression}, ${2:shift-bits} )"
    },
    "show_library_tab": {
        "description": "Undocumented",
        "signature": "show_library_tab",
        "snippet_string": "show_library_tab"
    },
    "signbit": {
        "description": "Sign bit (returns 1 if the number is negative, 0 otherwise)",
        "signature": "signbit(x)",
        "snippet_string": "signbit( ${1:x} )"
    },
    "sin": {
        "description": "sine function",
        "signature": "sin(x)",
        "snippet_string": "sin( ${1:x} )"
    },
    "slice_idx_loop_end": {
        "description": "Undocumented",
        "signature": "slice_idx_loop_end(arg1,arg2)",
        "snippet_string": "slice_idx_loop_end( ${1:arg1}, ${2:arg2} )"
    },
    "slice_idx_loop_start": {
        "description": "Undocumented",
        "signature": "slice_idx_loop_start(arg1,arg2)",
        "snippet_string": "slice_idx_loop_start( ${1:arg1}, ${2:arg2} )"
    },
    "slice_length": {
        "description": "Undocumented",
        "signature": "slice_length(arg1,arg2)",
        "snippet_string": "slice_length( ${1:arg1}, ${2:arg2} )"
    },
    "slice_loop_count": {
        "description": "Undocumented",
        "signature": "slice_loop_count(arg1,arg2)",
        "snippet_string": "slice_loop_count( ${1:arg1}, ${2:arg2} )"
    },
    "slice_start": {
        "description": "Undocumented",
        "signature": "slice_start(arg1,arg2)",
        "snippet_string": "slice_start( ${1:arg1}, ${2:arg2} )"
    },
    "sort": {
        "description": "searches the specified array for the specified value and returns the index of its first position.",
        "signature": "sort(array-variable,direction)",
        "snippet_string": "sort( ${1:array-variable}, ${2:direction} )"
    },
    "sqrt": {
        "description": "square root",
        "signature": "sqrt(x)",
        "snippet_string": "sqrt( ${1:x} )"
    },
    "stop_wait": {
        "description": "stops wait commands in the specified callback",
        "signature": "stop_wait(callback-ID,parameter)",
        "snippet_string": "stop_wait( ${1:callback-ID}, ${2:parameter} )"
    },
    "tan": {
        "description": "tangent function",
        "signature": "tan(x)",
        "snippet_string": "tan( ${1:x} )"
    },
    "ticks_to_ms": {
        "description": "converts a tempo dependent ticks value into a microseconds value",
        "signature": "ticks_to_ms(ticks)",
        "snippet_string": "ticks_to_ms( ${1:ticks} )"
    },
    "unload_slot": {
        "description": "Undocumented",
        "signature": "unload_slot(arg1)",
        "snippet_string": "unload_slot( ${1:arg1} )"
    },
    "wait": {
        "description": "pauses the callback for the specified time in microseconds",
        "signature": "wait(wait-time)",
        "snippet_string": "wait( ${1:wait-time} )"
    },
    "wait_async": {
        "description": "waits until the async command identified by the <asyncID> is finished",
        "signature": "wait_async(asyncID)",
        "snippet_string": "wait_async( ${1:asyncID} )"
    },
    "wait_ticks": {
        "description": "pauses the callback for the specified time in ticks",
        "signature": "wait_ticks(wait-time)",
        "snippet_string": "wait_ticks( ${1:wait-time} )"
    },
    "watch_array_idx": {
        "description": "Variable watching through Creator Tools",
        "signature": "watch_array_idx(arr,idx)",
        "snippet_string": "watch_array_idx( ${1:arr}, ${2:idx} )"
    },
    "watch_var": {
        "description": "Variable watching through Creator Tools",
        "signature": "watch_var(var)",
        "snippet_string": "watch_var( ${1:var} )"
    },
    "will_never_terminate": {
        "description": "",
        "signature": "will_never_terminate(event-id)",
        "snippet_string": "will_never_terminate( ${1:event-id} )"
    },
    "zone_slice_idx_loop_end": {
        "description": "returns the index number of the slice at the loop end",
        "signature": "zone_slice_idx_loop_end(zone-ID,loop-index)",
        "snippet_string": "zone_slice_idx_loop_end( ${1:zone-ID}, ${2:loop-index} )"
    },
    "zone_slice_idx_loop_start": {
        "description": "returns the index number of the slice at the loop start",
        "signature": "zone_slice_idx_loop_start(zone-ID,loop-index)",
        "snippet_string": "zone_slice_idx_loop_start( ${1:zone-ID}, ${2:loop-index} )"
    },
    "zone_slice_length": {
        "description": "returns the length in microseconds of the specified slice with respect to the current tempo",
        "signature": "zone_slice_length(zone-ID,slice-index)",
        "snippet_string": "zone_slice_length( ${1:zone-ID}, ${2:slice-index} )"
    },
    "zone_slice_loop_count": {
        "description": "returns the loop count of the specified loop",
        "signature": "zone_slice_loop_count(zone-ID,loop-index)",
        "snippet_string": "zone_slice_loop_count( ${1:zone-ID}, ${2:loop-index} )"
    },
    "zone_slice_start": {
        "description": "returns the absolute start point of the specified slice in microseconds, independent of the current tempo",
        "signature": "zone_slice_start(zone-ID,slice-index)",
        "snippet_string": "zone_slice_start( ${1:zone-ID}, ${2:slice-index} )"
    }
}
